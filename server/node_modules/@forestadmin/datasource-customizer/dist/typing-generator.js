"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
const promises_1 = require("fs/promises");
class TypingGenerator {
    /**
     * Write types to disk at a given path.
     * This method read the file which is already there before overwriting so that customers
     * using equivalents to nodemon to not enter restart loops.
     */
    static async updateTypesOnFileSystem(dataSource, typingsPath, typingsMaxDepth) {
        const newTypes = TypingGenerator.generateTypes(dataSource, typingsMaxDepth);
        let olderTypes = null;
        try {
            olderTypes = await (0, promises_1.readFile)(typingsPath, { encoding: 'utf-8' });
        }
        catch (e) {
            if (e.code === 'ENOENT')
                olderTypes = null;
            else
                throw e;
        }
        if (newTypes !== olderTypes) {
            await (0, promises_1.writeFile)(typingsPath, newTypes, { encoding: 'utf-8' });
        }
    }
    /**
     * Generates types on a string.
     */
    static generateTypes(dataSource, maxDepth) {
        const collections = [...dataSource.collections].sort((a, b) => a.name.localeCompare(b.name));
        return [
            `/* eslint-disable */`,
            `import {`,
            `  CollectionCustomizer,`,
            `  TAggregation,`,
            `  TConditionTree,`,
            `  TPaginatedFilter,`,
            `  TPartialRow,`,
            `  TSortClause`,
            `} from '@forestadmin/agent';`,
            '',
            this.generateAliases(dataSource),
            '',
            'export type Schema = {',
            ...collections.map(collection => [
                `  '${collection.name}': {`,
                this.getRow(collection),
                this.getRelations(collection),
                this.getFlatRelations(collection, maxDepth),
                '  };',
            ].join(`\n`)),
            '};\n',
        ].join('\n');
    }
    static generateAliases(dataSource) {
        return dataSource.collections
            .flatMap(collection => {
            const name = collection.name.slice(0, 1).toUpperCase() +
                collection.name.slice(1).replace(/_[a-z]/g, match => match.slice(1).toUpperCase());
            return [
                // eslint-disable-next-line max-len
                `export type ${name}Customizer = CollectionCustomizer<Schema, '${collection.name}'>;`,
                `export type ${name}Record = TPartialRow<Schema, '${collection.name}'>;`,
                `export type ${name}ConditionTree = TConditionTree<Schema, '${collection.name}'>;`,
                `export type ${name}Filter = TPaginatedFilter<Schema, '${collection.name}'>;`,
                `export type ${name}SortClause = TSortClause<Schema, '${collection.name}'>;`,
                `export type ${name}Aggregation = TAggregation<Schema, '${collection.name}'>;`,
                '',
            ];
        })
            .join('\n');
    }
    static getRow(collection) {
        const content = Object.entries(collection.schema.fields).reduce((memo, [name, field]) => {
            return field.type === 'Column' ? [...memo, `      '${name}': ${this.getType(field)};`] : memo;
        }, []);
        return `    plain: {\n${content.join('\n')}\n    };`;
    }
    static getRelations(collection) {
        const content = Object.entries(collection.schema.fields).reduce((memo, [name, field]) => {
            if (field.type === 'ManyToOne' || field.type === 'OneToOne') {
                const relation = field.foreignCollection;
                return [
                    ...memo,
                    `      '${name}': Schema['${relation}']['plain'] & Schema['${relation}']['nested'];`,
                ];
            }
            return memo;
        }, []);
        return content.length ? `    nested: {\n${content.join('\n')}\n    };` : `    nested: {};`;
    }
    static getFlatRelations(collection, maxDepth) {
        const fields = this.getFieldsRec(collection, maxDepth, []);
        return fields.length
            ? `    flat: {\n      ${fields.join('\n      ')}\n    };`
            : `    flat: {};`;
    }
    static getFieldsRec(collection, maxDepth, traversed) {
        const columns = traversed.length > 0
            ? Object.entries(collection.schema.fields)
                .filter(([, schema]) => schema.type === 'Column')
                .map(([name, schema]) => `'${name}': ${this.getType(schema)};`)
            : [];
        const relations = Object.entries(collection.schema.fields).reduce((memo, [name, schema]) => {
            if (schema.type !== 'ManyToOne' && schema.type !== 'OneToOne')
                return memo;
            const subCollection = collection.dataSource.getCollection(schema.foreignCollection);
            const inverse = datasource_toolkit_1.CollectionUtils.getInverseRelation(collection, name);
            // Do not expand inverse relations, as those create useless cycles
            const expand = traversed.length < maxDepth &&
                !traversed.find(({ c, r }) => c === subCollection && r === inverse);
            if (!expand)
                return memo;
            // Manually expand the field type (cycles are not allowed in template literal types)
            return [
                ...memo,
                ...this.getFieldsRec(subCollection, maxDepth, [
                    ...traversed,
                    { c: collection, r: name },
                ]).map(f => `'${name}:${f.slice(1)}`),
            ];
        }, []);
        return [...columns, ...relations];
    }
    static getType(field) {
        if (Array.isArray(field.columnType)) {
            return `Array<${this.getType({
                columnType: field.columnType[0],
                enumValues: field.enumValues,
            })}>`;
        }
        if (field.columnType === 'Enum') {
            return field.enumValues?.map(v => `'${v.replace(/'/g, "\\'")}'`).join(' | ') ?? 'string';
        }
        if (typeof field.columnType === 'string') {
            return {
                Boolean: 'boolean',
                Binary: 'Buffer',
                Date: 'string',
                Dateonly: 'string',
                Json: 'any',
                Number: 'number',
                Point: '[number, number]',
                String: 'string',
                Time: 'string',
                Uuid: 'string',
            }[field.columnType];
        }
        return `{${Object.entries(field.columnType)
            .map(([key, subType]) => `${key}: ${this.getType({ columnType: subType })}`)
            .join('; ')}}`;
    }
}
exports.default = TypingGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwaW5nLWdlbmVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90eXBpbmctZ2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsd0VBTXlDO0FBQ3pDLDBDQUFrRDtBQUVsRCxNQUFxQixlQUFlO0lBQ2xDOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUNsQyxVQUFzQixFQUN0QixXQUFtQixFQUNuQixlQUF1QjtRQUV2QixNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUM1RSxJQUFJLFVBQVUsR0FBa0IsSUFBSSxDQUFDO1FBRXJDLElBQUk7WUFDRixVQUFVLEdBQUcsTUFBTSxJQUFBLG1CQUFRLEVBQUMsV0FBVyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDakU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRO2dCQUFFLFVBQVUsR0FBRyxJQUFJLENBQUM7O2dCQUN0QyxNQUFNLENBQUMsQ0FBQztTQUNkO1FBRUQsSUFBSSxRQUFRLEtBQUssVUFBVSxFQUFFO1lBQzNCLE1BQU0sSUFBQSxvQkFBUyxFQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBc0IsRUFBRSxRQUFnQjtRQUMzRCxNQUFNLFdBQVcsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRTdG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