"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
class FrontendValidationUtils {
    /** Convert a list of our validation rules to what we'll be sending to the frontend */
    static convertValidationList(column) {
        if (!column.validation)
            return [];
        const rules = column.validation.flatMap(rule => this.simplifyRule(column.columnType, rule));
        this.removeDuplicatesInPlace(rules);
        return rules.map(rule => this.supported[rule.operator](rule));
    }
    /** Convert one of our validation rules to a given number of frontend validation rules */
    static simplifyRule(columnType, rule) {
        // Operators which we don't want to end up the schema
        if (this.excluded.has(rule.operator))
            return [];
        // Operators which are natively supported by the frontend
        if (this.supported[rule.operator])
            return [rule];
        try {
            // Add the 'Equal|NotEqual' operators to unlock the `In|NotIn -> Match` replacement rules.
            // This is a bit hacky, but it allows to reuse the existing logic.
            const operators = new Set(Object.keys(this.supported));
            operators.add('Equal');
            operators.add('NotEqual');
            // Rewrite the rule to use only operators that the frontend supports.
            const leaf = new datasource_toolkit_1.ConditionTreeLeaf('field', rule.operator, rule.value);
            const timezone = 'Europe/Paris'; // we're sending the schema => use random tz
            const tree = datasource_toolkit_1.ConditionTreeEquivalent.getEquivalentTree(leaf, operators, columnType, timezone);
            let conditions = [];
            if (tree instanceof datasource_toolkit_1.ConditionTreeLeaf) {
                conditions = [tree];
            }
            else if (tree instanceof datasource_toolkit_1.ConditionTreeBranch && tree.aggregator === 'And') {
                conditions = tree.conditions;
            }
            return conditions
                .filter(c => c instanceof datasource_toolkit_1.ConditionTreeLeaf)
                .filter(c => c.operator !== 'Equal' && c.operator !== 'NotEqual')
                .flatMap(c => this.simplifyRule(columnType, c));
        }
        catch {
            // Just ignore errors, they mean that the operator is not supported by the frontend
            // and that we don't have an automatic conversion for it.
            //
            // In that case we fallback to just validating the data entry in the agent (which is better
            // than nothing but will not be as user friendly as the frontend validation).
        }
        // Drop the rule if we don't know how to convert it (we could log a warning here).
        return [];
    }
    /**
     * The frontend crashes when it receives multiple rules of the same type.
     * This method merges the rules which can be merged and drops the others.
     */
    static removeDuplicatesInPlace(rules) {
        const used = new Map();
        for (let i = 0; i < rules.length; i += 1) {
            if (used.has(rules[i].operator)) {
                const rule = rules[used.get(rules[i].operator)];
                const [newRule] = rules.splice(i, 1);
                i -= 1;
                this.mergeInto(rule, newRule);
            }
            else {
                used.set(rules[i].operator, i);
            }
        }
    }
    static mergeInto(rule, newRule) {
        if (rule.operator === 'GreaterThan' ||
            rule.operator === 'After' ||
            rule.operator === 'LongerThan') {
            rule.value = rule.value < newRule.value ? newRule.value : rule.value;
        }
        else if (rule.operator === 'LessThan' ||
            rule.operator === 'Before' ||
            rule.operator === 'ShorterThan') {
            rule.value = rule.value < newRule.value ? rule.value : newRule.value;
        }
        else if (rule.operator === 'Match') {
            // Make one big regex that matches both patterns
            // @see https://stackoverflow.com/a/870506/1897495
            const regexp = rule.value;
            const newRegexp = newRule.value;
            rule.value = new RegExp(`^(?=${regexp.source})(?=${newRegexp.source}).*$`, regexp.flags);
        }
        else {
            // Ignore the rules that we can't deduplicate (we could log a warning here).
        }
    }
}
exports.default = FrontendValidationUtils;
/**
 * Those operators depend on the current time so they won't work.
 * The reason is that we need now() to be evaluated at query time, not at schema generation time.
 */
FrontendValidationUtils.excluded = new Set([
    ...['Future', 'Past', 'Today', 'Yesterday'],
    ...['PreviousMonth', 'PreviousQuarter', 'PreviousWeek', 'PreviousXDays', 'PreviousYear'],
    ...['AfterXHoursAgo', 'BeforeXHoursAgo', 'PreviousXDaysToDate'],
    ...['PreviousMonthToDate', 'PreviousQuarterToDate', 'PreviousWeekToDate', 'PreviousYearToDate'],
]);
/** This is the list of operators which are supported in the frontend implementation */
FrontendValidationUtils.supported = {
    Present: () => ({ type: 'is present', message: 'Field is required' }),
    After: rule => ({
        type: 'is after',
        value: rule.value,
        message: `Value must be after ${rule.value}`,
    }),
    Before: rule => ({
        type: 'is before',
        value: rule.value,
        message: `Value must be before ${rule.value}`,
    }),
    Contains: rule => ({
        type: 'contains',
        value: rule.value,
        message: `Value must contain '${rule.value}'`,
    }),
    GreaterThan: rule => ({
        type: 'is greater than',
        value: rule.value,
        message: `Value must be greater than ${rule.value}`,
    }),
    LessThan: rule => ({
        type: 'is less than',
        value: rule.value,
        message: `Value must be lower than ${rule.value}`,
    }),
    LongerThan: rule => ({
        type: 'is longer than',
        value: rule.value,
        message: `Value must be longer than ${rule.value} characters`,
    }),
    ShorterThan: rule => ({
        type: 'is shorter than',
        value: rule.value,
        message: `Value must be shorter than ${rule.value} characters`,
    }),
    Match: rule => ({
        type: 'is like',
        value: rule.value.toString(),
        message: `Value must match ${rule.value}`,
    }),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9mb3Jlc3Qtc2NoZW1hL3ZhbGlkYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx3RUFPeUM7QUFNekMsTUFBcUIsdUJBQXVCO0lBeUQxQyxzRkFBc0Y7SUFDdEYsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE1BQW9CO1FBQy9DLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVTtZQUFFLE9BQU8sRUFBRSxDQUFDO1FBRWxDLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDNUYsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXBDLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVELHlGQUF5RjtJQUNqRixNQUFNLENBQUMsWUFBWSxDQUFDLFVBQXNCLEVBQUUsSUFBZ0I7UUFDbEUscURBQXFEO1FBQ3JELElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUFFLE9BQU8sRUFBRSxDQUFDO1FBRWhELHlEQUF5RDtRQUN6RCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVqRCxJQUFJO1lBQ0YsMEZBQTBGO1lBQzFGLGtFQUFrRTtZQUNsRSxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxD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